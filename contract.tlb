nothing$0   {X:Type} = Maybe X;
just$1      {X:Type} value:X = Maybe X;

// ---------- addresses -----------
addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len)
    = MsgAddressExt;

anycast_info$_ depth:(#<= 30) { depth >= 1 }
    rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
    workchain_id:int8 address:bits256 = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;

_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

addr_none$00 = MsgAddressNone;
addr_std$10 anycast:(## 1) {anycast = 0}
    workchain_id:int8 address:bits256 = MsgAddressSmpl;

// ---------- coins -----------
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
    = VarUInteger n;

nanotons$_ amount:(VarUInteger 16) = Grams;

// ---------- minter ico -----------
storage#_ total_supply:Grams admin_address:MsgAddressSmpl
    liquidity_capping:Grams price:Grams end_time:uint32
    jetton_wallet_code:^Cell content:^Cell = Storage;

// ---- mini jetton matadata standart ----
/*
*symbol_size:    uint byte size of future ASCII string (max value is 2^3-1, i.e. 7)
*symbol:         ASCII string, token symbol, max value:56 bit (i.e. 7 bytes ---> ↑)

*name_size:      uint byte size of future ASCII string (max value is 2^4-1, i.e. 15)
*name:           ASCII string, token name, max value:120 bit (i.e. 15 bytes ----> ↑)

icon_uri:        an ASCII string link to the token icon, for example an ipfs url
                 max recommended value: 1023-(3+4+56+120) (i.e. 840 bit, 105 bytes);
                 may take more space if symbol and name < (56+120) bit (i.e. < 176 bit)

Note: fields marked with * are required.
*/

nothing$0 {X:Type} = Maybe X;       // from block.tlb //
just$1 {X:Type} value:X = Maybe X;  // from block.tlb //

mini_data#11 symbol_size:uint3 symbol:bits
    name_size:uint4 name:bits icon_uri:bits = Content;
// ---------------------------------------