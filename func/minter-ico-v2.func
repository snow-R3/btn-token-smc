;; biton minter ICO smart contract

;; basic exti codes
int ext_code::err_addr_format() asm "1001 PUSHINT";

;; mint exit codes
int ext_code::err_auth() asm "1002 PUSHINT";

(int, int, int, int, slice, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_grams(),      ;; supply
        ds~load_grams(),      ;; liq_cap
        ds~load_grams(),      ;; price
        ds~load_uint(32),     ;; end_time (unix format)
        ds~load_msg_addr(),   ;; owner_addr
        ds~load_ref(),        ;; jwall_code
        ds~load_ref()         ;; content
    );
}

() save_data(
    int supply, int liq_cap, int price, int end_time,
    slice owner_addr, cell jwall_code, cell content
) impure inline {
    set_data(begin_cell()
                .store_grams(supply)
                .store_grams(liq_cap)
                .store_grams(price)
                .store_uint(end_time, 32)
                .store_slice(owner_addr)
                .store_ref(jwall_code)
                .store_ref(content)
            .end_cell());
}

() auth_by_owner(slice sender_addr, slice owner_addr) impure inline {
    ;; thorw auth error if sender address != owner_addr
    throw_unless(
        ext_code::err_auth(),
        extlib::slice_data_equal?(sender_addr, owner_addr)
    );
}

(int {- jetton_amount -} ) mint_tokens(slice msg_body, cell jwall_code) impure inline {
    slice to_address = msg_body~load_msg_addr();
    int amount = msg_body~load_grams();
    cell master_msg = msg_body~load_ref();

    slice mm_cs = master_msg.begin_parse().skip_bits(32 + 64);

    cell state_init = jwall_state_init(
        to_address,     ;; mint to
        my_address(),   ;; minter-ico address (self)
        jwall_code      ;; code cell of jetton wallet
    );

    slice to_wallet_address = jwall_state_addr(state_init);

    builder msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_grams(amount)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(master_msg);

    send_raw_message(msg.end_cell(), 1);

    slice msc = master_msg.begin_parse().skip_bits(32 + 64);
    return msc~load_grams();
}

() recv_internal(int my_balance, int msg_value, cell msg, slice msg_body) impure {
    slice cs = msg.begin_parse();

    throw_if(0, cs~load_uint(4) & 1);  ;; return on bounce
    slice sender_addr = cs~load_msg_addr();

    throw_unless(  ;; thow error if address isn't MsgAddrSmpl
        ext_code::err_addr_format(),
        extlib::is_addrsmpl(sender_addr)
    );

    int op = msg_body~load_uint(32);
    throw_if(0, op == 0);  ;; ignore simple messages with comment
;;     int query_id = msg_body~load_uint(64);

    (
        int supply, int liq_cap, int price, int end_time,
        slice owner_addr, cell jwall_code, cell content
    ) = load_data();

    if (op == op::mint()) {
        auth_by_owner(sender_addr, owner_addr);
        save_data(
            supply + mint_tokens(msg_body, jwall_code), liq_cap, price,
            end_time, owner_addr, jwall_code, content
        );
        return ();
    }

    ;; TODO: implement op::burn_notification
    ;; TODO: implement op::withdraw()

    throw(0xffff);
}

;; TODO: implement get methods