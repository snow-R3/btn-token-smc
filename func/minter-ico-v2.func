;; biton minter ICO smart contract

;; basic exti codes
int ext_code::err_addr_format() asm "1001 PUSHINT";
;; mint exit codes
int ext_code::err_auth() asm "1002 PUSHINT";

slice txt::from_ico() asm "<b 124 word BTN from ICO| $, b> <s PUSHSLICE";

(slice) parse_data() inline { return get_data().begin_parse(); }

(int, int, int, int, slice, cell, cell) load_data() inline {
    slice ds = parse_data();
    return (
        ds~load_grams(),      ;; supply
        ds~load_grams(),      ;; liq_cap
        ds~load_grams(),      ;; price
        ds~load_uint(32),     ;; end_time (unix format)
        ds~load_msg_addr(),   ;; owner_addr
        ds~load_ref(),        ;; jwall_code

        ds~load_ref()         ;; content ;; TODO: change content to name and symbol
    );
}

() save_data(
    int supply, int liq_cap, int price, int end_time,
    slice owner_addr, cell jwall_code, cell content
) impure inline {
    set_data(begin_cell()
                .store_grams(supply)
                .store_grams(liq_cap)
                .store_grams(price)
                .store_uint(end_time, 32)
                .store_slice(owner_addr)
                .store_ref(jwall_code)
                .store_ref(content)
            .end_cell());
}

() auth_by_owner(slice sender_addr, slice owner_addr) impure inline {
    ;; thorw auth error if sender address != owner_addr
    throw_unless(
        ext_code::err_auth(),
        extlib::slice_data_equal?(sender_addr, owner_addr)
    );
}

(
    slice {- to_address -}, int {- amount -},
    cell {- master_msg -}, int {- jetton_amount -}
) parse_body_mint(slice msg_body) inline {
    slice   to_address      = msg_body~load_msg_addr();
    int     amount          = msg_body~load_grams();
    cell    master_msg      = msg_body~load_ref();
    slice   msc             = master_msg.begin_parse().skip_bits(32 + 64);
    int     jetton_amount   = msc~load_grams();

    return (to_address, amount, master_msg, jetton_amount);
}

(int {- jetton_amount -} ) mint_tokens(data, cell jwall_code) impure inline {
    (slice to_address, int amount, cell master_msg, int jetton_amount) = data;

    cell state_init = jwall_state_init(
        to_address,     ;; mint to
        my_address(),   ;; minter-ico address (self)
        jwall_code      ;; code cell of jetton wallet
    );

    builder msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jwall_state_addr(state_init))
        .store_grams(amount)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(master_msg);

    send_raw_message(msg.end_cell(), 1);
    return jetton_amount;
}

(   int {- op -}, int {- query_id -},
    slice {- sender_addr -}
) handle::start(cell msg, slice msg_body) impure inline {
     slice cs = msg.begin_parse();
     throw_if(0, cs~load_uint(4) & 1);  ;; return on bounce

     slice sender_addr = cs~load_msg_addr();

     throw_unless(  ;; thow error if address isn't MsgAddrSmpl
         ext_code::err_addr_format(),
         extlib::is_addrsmpl(sender_addr)
     );

     int op = msg_body~load_uint(32);
     throw_if(0, op == 0);  ;; ignore simple messages with comment
     int query_id = msg_body~load_uint(64);

     return (op, query_id, sender_addr);
}

() handle:buy_tokens(int msg_value, slice sender_addr) impure inline {
    (
        int supply, int liq_cap, int price, int end_time,
        slice owner_addr, cell jwall_code, cell content
    ) = load_data();

    throw_if(75, supply >= liq_cap);
    throw_if(76, now() > end_time);

    int mint_amount = 1 << 24;  ;; ~ 0.01677 TON
    int buy_amount = msg_value - mint_amount;
    throw_if(76, buy_amount < price);

    int jamount = buy_amount * extlib::1gram() / price;

    cell master_msg = begin_cell()                  ;; begin_cell
        .store_uint(op::internal_transfer(), 32)    ;; op internal_transfer
        .store_uint(cur_lt(), 64)       ;; query_id
        .store_grams(jamount)           ;; amount
        .store_slice(my_address())      ;; from
        .store_slice(sender_addr)       ;; response_address
        .store_grams(1)                 ;; forward_ton_amount
        .store_int(0, 1)                ;; forward_payload [Either Cell ^Cell] bit
        .store_uint(0, 32)              ;; op 0 â€“ trasfer comment
        .store_slice(txt::from_ico())   ;; trasfer comment text
        .end_cell();                    ;; end of cell

    save_data(
        supply + mint_tokens((sender_addr, mint_amount, master_msg, jamount), jwall_code),
        liq_cap, price, end_time, owner_addr, jwall_code, content
    );
}

() handle::mint(slice msg_body, slice sender_addr) impure inline {
    (
        int supply, int liq_cap, int price, int end_time,
        slice owner_addr, cell jwall_code, cell content
    ) = load_data();

    var parsed_body = parse_body_mint(msg_body);
    auth_by_owner(sender_addr, owner_addr);
    save_data(
        supply + mint_tokens(parsed_body, jwall_code), liq_cap, price,
        end_time, owner_addr, jwall_code, content
    );
}

() recv_internal(int my_balance, int msg_value, cell msg, slice msg_body) impure {
    (int op, _ {- query_id -}, slice sender_addr) = handle::start(msg, msg_body);

    if (op == op::mint()) { handle::mint(msg_body, sender_addr); return (); }
    if (op == op::buy_tokens()) { handle:buy_tokens(msg_value, sender_addr); return (); }

    ;; TODO: implement op::burn_notification
    ;; TODO: implement op::withdraw()

    throw(0xffff);
}

(int) name() method_id { return 1; {- biton -} } ;; TODO: return "biton" as int
(int) symbol() method_id { return 1; {- BTN -} } ;; TODO: return "BTN" as int

(int {- wc -}, int {- addr -}) owner() method_id {
    (_, _, _, _, slice owner_addr, _, _) = load_data();
    return parse_std_addr(owner_addr);
}

(int) total_supply() method_id {
    (_, int total_supply) = parse_data().load_grams();
    return total_supply;
}

(int {- liq_cap -}, int {- price -}, int {- end_time -}) get_ico_data() method_id {
    (slice ds, _) = parse_data().load_grams();
    return (ds~load_grams(), ds~load_grams(), ds~load_grams());
}